# Время

## <font color="tomato">Реализация программы напоминания о днях рождения</font>

Реализуйте простую программу по вычислению ближайшего дня рождения.

В начале программы пользователь последовательно вводит данные о днях рождения своих друзей: 
вводит имя друга и саму дату рождения полностью, включая месяц и год, в формате год/месяц/день. 
Сигналом окончания ввода дней рождения является “end” введённое в качестве имени.

После этого программа вычисляет ближайший день рождения по отношению к текущему времени 
и выводит его на экран вместе с именем в удобном, локальном формате - месяц/день. 
Если день рождения уже был в этом году, данные о пользователе пропускаются. 
Если у кого-то из друзей день рождения сегодня, то в консоль выводится специальное сообщение об этом. 

Учтите, что таких сообщений может быть несколько, ведь сразу несколько людей могут иметь 
дни рождения в один день.

## <font color="tomato">Объяснение решения</font>

Создаём структуру на основе std::map. Выглядеть она будет как:

```text
std::map<int, vector<std::string>> calendar
{ день_с_начала_текущего_года: { "Sun Aug 20 10:23:44 2023", realDate, name_2 ... }
```
Где в качестве ключа будет выступать номер дня в текущем году. 
Значениями же (в формате строк) - последовательный список из имени человека и его даты рождения. 

Все манипуляции с датами будут основываться на типе time_t. 
Извлекать части, распечатывать, изменять даты можно будет в конкретно предназначенных для этого функциях, 
возвращая, после этого, даты обратно в тип time_t.

Для того чтобы получить дату рождения человека в функции `addEntry` создаем формат. 
Он будет управлять тем, что пользователь, в конечном счете, будет вводить в функции `putTimeByFormat`. 
Например, в программе есть задача: ввести год, месяц и день. Поэтому передаем строку 

```c++
string format = "YYYY/mm/dd";
```
Это означает, что `putTimeByFormat` вызовется три раза - каждый раз получая в качестве аргумента 
одну из букв каждой части: сначала 'Y', потом 'm' и 'd'. 
Эти аргументы, переданные в функцию `putTimeByFormat`, зададут тип параметра, который будет меняться в 
`std::get_time`. На самом деле функции `putTimeByFormat` и `putTime` могут принимать любой тип формата, 
который корректен для функции `std::get_time`. Например, 'HH:MM:SS'

Второй аргумент - basisTime - будет подставляться в std::get_time, изменяясь. Его же функция будет возвращать 
обратно, снова в виде формата time_t. Это позволит на каждой итерации из `putTimeByFormat` обновлять 
одно единственное значение, вызывая его каждый раз.

Функция `putTime` отслеживает ввод и если пользователь введет дату ранее January 1, 1970 
или некорректный тип данных - например char - предложит попробовать новый ввод. 
Важно то, что нет ограничения по вводу дат из будущего. Можно и это сделать, но в рамках задачи не стал это делать.


## <font color="tomato">Полезные ссылки</font>

[HOW TO CONVERT DATE STRING TO TIME_T](https://www.appsloveworld.com/cplus/100/631/how-to-convert-date-string-to-time-t)

[std::get_time](https://en.cppreference.com/w/cpp/io/manip/get_time)

[std::get_time](https://cplusplus.com/reference/iomanip/get_time/)

[mktime](https://cplusplus.com/reference/ctime/mktime/)

[map::lower_bound](https://cplusplus.com/reference/map/map/lower_bound/)


