# Время

## <font color="tomato">Реализация программы напоминания о днях рождения</font>

Реализуйте простую программу по вычислению ближайшего дня рождения.

В начале программы пользователь последовательно вводит данные о днях рождения своих друзей: 
вводит имя друга и саму дату рождения полностью, включая месяц и год, в формате год/месяц/день. 
Сигналом окончания ввода дней рождения является “end” введённое в качестве имени.

После этого программа вычисляет ближайший день рождения по отношению к текущему времени 
и выводит его на экран вместе с именем в удобном, локальном формате - месяц/день. 
Если день рождения уже был в этом году, данные о пользователе пропускаются. 
Если у кого-то из друзей день рождения сегодня, то в консоль выводится специальное сообщение об этом. 

Учтите, что таких сообщений может быть несколько, ведь сразу несколько людей могут иметь 
дни рождения в один день.

## <font color="tomato">Объяснение решения</font>

Создаём структуру на основе std::map. Выглядеть она будет как:

```text
std::map<int, vector<std::string>> calendar
{ день_с_начала_текущего_года: { "Sun Aug 20 10:23:44 2023", realDate, name_2 ... }
```
В качестве ключа будет выступать номер дня в текущем году (т.е. отсчитывая от 1 января). 
Значениями же (в формате строк) - будет последовательный список из имени человека и его даты рождения. 

Все манипуляции с датами будут основываться на типе time_t. 
Извлекать части, распечатывать, изменять даты можно будет в конкретно предназначенных для этого функциях, 
возвращая, после этого, даты снова в тип time_t.

Для того чтобы получить дату рождения человека - в функции `addEntry` создаем строку с форматом. 
Формат будет управлять тем, что пользователь будет вводить в функции `putTimeByFormat`. 
Например, в программе есть задача: ввести год, месяц и день. Однако это может быть и, например, время. 

```c++
string format = "YYYY/mm/dd";
string format = "HH:MM:SS";
```

Во втором случае разделителем нужно будет указать двоеточие.

В приведенных примерах `putTimeByFormat` вызовется по три раза - каждый раз получая в качестве аргумента 
одну из букв каждой части: сначала 'Y', потом 'm' и 'd'. 
Эти аргументы, переданные в функцию `putTimeByFormat`, зададут тип параметра, который будет меняться в 
`std::get_time`.

Второй аргумент - basisTime - будет подставляться в std::get_time, изменяясь. Функция, в итоге, будет возвращать 
его обратно, снова в виде формата time_t. Это позволит на каждой итерации из `putTimeByFormat` обновлять 
одно единственное значение, вызывая его каждый раз, но для своего формата.

Функция `putTime` отслеживает ввод и если пользователь введет дату ранее January 1, 1970 
или некорректный тип данных - например букву - предложит попробовать новый ввод. 
Важно то, что нет ограничения по вводу дат из будущего. 
Если понадобится, то сделать это можно просто добавив сравнение с текущим временем. 
Ведь человек не может родиться позже чем сейчас :)

Функция `addEntry`. Как указывалось выше, вся логика std::map строится на концепции ключа, 
в который мы помещаем день от 1 января текущего года. 
Иначе говоря, если человек родился в 2000 году 06/06, то 06/06 и будет искомым ключом. 
Извлечь ключ можно, если из дату перевести в структуру tm* и получить из неё поле tm_year. 
В итоге получим 156. 
Однако здесь есть подводный камень: в високосном году на один день больше. Это решается формулой:

```c++
(year % 400 == 0 || year % 100 != 0) && year % 4 == 0
```
Т.о. если год високосный, то день вычитаем один день. 
Для более точного расчета можно также внести дополнительное условие, учитывая дату до 1 марта для високосного года.



## <font color="tomato">Полезные ссылки</font>

[HOW TO CONVERT DATE STRING TO TIME_T](https://www.appsloveworld.com/cplus/100/631/how-to-convert-date-string-to-time-t)

[std::get_time](https://en.cppreference.com/w/cpp/io/manip/get_time)

[std::get_time](https://cplusplus.com/reference/iomanip/get_time/)

[mktime](https://cplusplus.com/reference/ctime/mktime/)

[map::lower_bound](https://cplusplus.com/reference/map/map/lower_bound/)


